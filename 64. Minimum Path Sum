class Solution {
    private int minPath(int i, int j, int[][] grid, int[][] dp) {
        if(i == 0 && j == 0) {
            return dp[0][0] = grid[0][0];
        }

        if(i < 0 || j < 0) {
            return (int)1e9;
        }

        if(dp[i][j] != -1) {
            return dp[i][j];
        }

        int up = grid[i][j] + minPath(i-1, j, grid, dp);
        int side = grid[i][j] + minPath(i, j-1, grid, dp);

        return dp[i][j] = Math.min(up, side);
    }

    public int minPathSum(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;

        int[][] dp = new int[n][m];
        for(int i=0; i<n; i++) {
            Arrays.fill(dp[i], -1);
        }

        return minPath(n-1, m-1, grid, dp);
    }
}


//###### Another approach
// class Solution {
//     public int minPathSum(int[][] grid) {
//         int n = grid.length;
//         int m = grid[0].length;

//         int[][] dp = new int[n][m];
//         dp[0][0] += grid[0][0];
//         for(int i=1; i<m; i++) {
//             dp[0][i] += (grid[0][i] + dp[0][i-1]);
//         }

//         for(int j=1; j<n; j++) {
//             dp[j][0] += (grid[j][0] + dp[j-1][0]);
//         }

//         for(int i=1; i<n; i++) {
//             for(int j=1; j<m; j++) {
//                 dp[i][j] += Math.min((grid[i][j] + dp[i][j-1]), (grid[i][j] + dp[i-1][j]));
//             }
//         }

//         return dp[n-1][m-1];
//     }
// }
