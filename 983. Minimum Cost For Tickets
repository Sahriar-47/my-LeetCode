class Solution {
    private int solve(int curDay, int len, int[] days, int[] costs, int[] dp, HashSet<Integer> isPresentDay) {
        if(curDay > days[len-1]) {
            return 0;
        }
        if(!isPresentDay.contains(curDay)) {
            return solve(curDay+1, len, days, costs, dp, isPresentDay);
        }
        if(dp[curDay] != -1) return dp[curDay];

        int cost1 = costs[0] + solve(curDay+1, len, days, costs, dp, isPresentDay);
        int cost7 = costs[1] + solve(curDay+7, len, days, costs, dp, isPresentDay);
        int cost30 = costs[2] + solve(curDay+30, len, days, costs, dp, isPresentDay);

        return dp[curDay] = Math.min(cost1, Math.min(cost7, cost30));
    }

    public int mincostTickets(int[] days, int[] costs) {
        int len = days.length;
        HashSet<Integer> isPresentDay = new HashSet<>();
        for(int day: days) {
            isPresentDay.add(day);
        }
        int[] dp = new int[days[len-1]+1];
        Arrays.fill(dp, -1);

        return solve(1, len, days, costs, dp, isPresentDay);
    }
}








//Another Solution

class Solution {
    private int solve(int ind, int len, int[] days, int[] costs, int[] dp) {
        if(ind > len-1) {
            return 0;
        }
        if(dp[ind] != -1) return dp[ind];

        int cost1 = costs[0] + solve(ind+1, len, days, costs, dp);
        int i = ind;
        while(i < len && days[i] < days[ind]+7) {
            i++;
        }
        int cost7 = costs[1] + solve(i, len, days, costs, dp);

        i = ind;
        while(i < len && days[i] < days[ind]+30) {
            i++;
        }
        int cost30 = costs[2] + solve(i, len, days, costs, dp);
        return dp[ind] = Math.min(cost1, Math.min(cost7, cost30));
    }

    public int mincostTickets(int[] days, int[] costs) {
        int len = days.length;

        int[] dp = new int[len];
        Arrays.fill(dp, -1);
        return solve(0, len, days, costs, dp);
    }
}
