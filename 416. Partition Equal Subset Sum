class Solution {
    private boolean solve(int ind, int target, int[] ar, int[][] dp) {
        if(target == 0) return true;
        if(ind == 0) {
            return ar[0] == target;
        }

        if(dp[ind][target] != -1) {
            if(dp[ind][target] == 1) return true;
            else return false;
        }

        boolean notPick = solve(ind-1, target, ar, dp);
        boolean pick = false;
        if(target - ar[ind] >= 0) {
            pick = solve(ind-1, target-ar[ind], ar, dp);
        }
        dp[ind][target] = (pick | notPick) ? 1:0;

        return pick | notPick;
    }
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        int sum = 0;
        for(int i=0; i<n; i++) {
            sum += nums[i];
        }
        if(sum%2 == 1)
        return false;

        sum /= 2;
        int[][] dp = new int[n][sum+1];
        for(int[] dpAr: dp) {
            Arrays.fill(dpAr, -1);
        }

        return solve(n-1, sum, nums, dp);
    }
}


// Another Approach

// class Solution {
//     public boolean canPartition(int[] nums) {
//         int sum = 0;
//         for (int x : nums) sum += x;

//         if ((sum & 1) == 1) return false;

//         int target = sum / 2;
//         boolean[] dp = new boolean[target + 1];
//         dp[0] = true;

//         for (int num : nums) {
//             for (int j = target; j >= num; j--) {
//                 dp[j] |= dp[j - num];
//             }
//         }
//         return dp[target];
//     }
// }
